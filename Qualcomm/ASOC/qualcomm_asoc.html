<!DOCTYPE html>
<html>
<head><style>
/*
Powered by Mybase Desktop 8.2 Beta-5
Copyright 1998-2022 Wjj Software. All Rights Reserved.
http://www.wjjsoft.com
info@wjjsoft.com
*/

/********** nyf://appres?id=default-charformat-css-for-html **********/

body, table{background-color: rgba(135, 206, 235, 0.392157); font-family: "Microsoft YaHei Mono"; font-size: 13.5pt}

/********** nyf://localhost/${basetheme}/htmldoc_code.css **********/

pre{
	white-space: pre;
	margin-right: 0.5em;
	padding: 0px;
	border: 1px solid #d6d6d6;
	border-radius: 6px;
}
code{
	font-family: Monaco, Consolas, Monospace, Courier;
	white-space: pre-wrap;
	word-break: break-all;
	border-radius: 6px;
}

/********** nyf://localhost/${basetheme}/htmldoc_table.css **********/

table{
	padding: 0;
	border-collapse: collapse;
	border: 1px solid gray;
	border-width: 3px 1px 3px 1px;
}
tr{
	margin: 0px;
	padding: 0px;
}
tr:nth-child(2n){
	background-color: #f8f8f8;
	background-color: rgba(135, 206, 235, 0.392157);
}
th{
	padding: 2px 5px;
	font-weight: bold;
	text-align: center;
	color: #e9e9e9;
	background-color: lightslategrey;
}
td{
	padding: 5px;
	border: 1px solid grey;
}

/********** nyf://appres?id=default-paragraph-css-for-html **********/

/********** nyf://localhost/${basetheme}/htmldoc.css **********/

body{
	background-color: transparent;
	background-color: rgba(135, 206, 235, 0.392157);
	background-color: #87ceeb;
	background-color: rgba(135, 206, 235, 0.392157);
}
body, p, div, li, label, table, th, td, blockquote, h1, h2, h3, h4, h5, h6, h7, dd, dl, dt, label, pre, code{
}
::selection{
}
img{
	max-width: 100%;
}

/********** nyf://localhost/${basetheme}/htmldoc_anchor.css **********/

a{
	text-decoration: none;
	color: #0366e6;
}
a:hover {
	cursor: pointer;
	text-decoration: none;
	background: url(nyf://appres?id=icon-by-key&ico=Img.Link.Wave&type=svg) repeat-x 0 100%;
	background-size: 20px auto;
	animation: wave0 1s 10 linear;
}
@keyframes wave0 {
	0% { background-position: 0 100%; }
	100% { background-position: -20px 100%; }
}

/********** nyf://localhost/${basetheme}/htmldoc_thread.css **********/

.CLS_THREAD {
	color: #0366e6;
	
}
.CLS_THREAD:hover {
	cursor: pointer;
}
.CLS_THREAD:hover {
	text-decoration: none;
	background: url(nyf://appres?id=icon-by-key&ico=Img.Link.Wave&type=svg) repeat-x 0 100%;
	background-size: 20px auto;
	animation: wave0 1s infinite linear;
}

/********** nyf://localhost/${basetheme}/htmldoc_toc.css **********/

div#ID_NYF_TOC_PANE *{
	margin: 0px;
	padding: 0px;
}
div#ID_NYF_TOC_PANE {
	margin: 0px;
	padding: 0px;
	border: 1px solid black;
	border: 1px solid #6ba3bb;
	border: 1px solid #6ba3bb;
	border-radius: 6px;
	background-color: lightyellow;
	background-color: #8cd6f4;
}
div#ID_NYF_TOC_PANE a:hover {
	color: crimson;
}
div#ID_NYF_TOC_TITLEBAR{
	border-bottom: 1px solid lightgrey;
	border-bottom: 1px solid #6ba3bb;
	border-bottom: 1px solid #6ba3bb;
}
div#ID_NYF_TOC_TITLETEXT{
	padding: 6px 6px 6px 16px;
	font-weight: bold;
	font-size: large;
}
div#ID_NYF_TOC_LISTVIEW{
	padding-right: 0.5em;
	margin: 0.5em 0;
}
img#ID_NYF_TOC_BTNCLOSE{
	width: 16px;
	height: 16px;
	cursor: pointer;
	padding: 2px;
	margin: 3px;
}
.CLS_NYF_TOC_LISTITEM {
}
.CLS_NYF_TOC_HREF {
	font-size: small;
	text-decoration: underline;
	line-height: 150%;
}

/********** nyf://localhost/${scripts}/hljs/styles/${SyntaxHighlightStyleName}.css **********/

.hljs {
  color: #a9b7c6;
  background: #282b2e;
  display: block;
  overflow-x: auto;
  padding: 0.5em;
}
.hljs-number,
.hljs-literal,
.hljs-symbol,
.hljs-bullet {
  color: #6897BB;
}
.hljs-keyword,
.hljs-selector-tag,
.hljs-deletion {
  color: #cc7832;
}
.hljs-variable,
.hljs-template-variable,
.hljs-link {
  color: #629755;
}
.hljs-comment,
.hljs-quote {
  color: #808080;
}
.hljs-meta {
  color: #bbb529;
}
.hljs-string,
.hljs-attribute,
.hljs-addition {
  color: #6A8759;
}
.hljs-section,
.hljs-title,
.hljs-type {
  color: #ffc66d;
}
.hljs-name,
.hljs-selector-id,
.hljs-selector-class {
  color: #e8bf6a;
}
.hljs-emphasis {
  font-style: italic;
}
.hljs-strong {
  font-weight: bold;
}

/********** fixes/tweaks 2022.1.19 **********/

a{margin-left: 4px; margin-right: 4px;}
a:hover{text-decoration: underline;}
hr{border: 0px; height: 2px; background: gray;}

</style></head>
<body>
&nbsp; &nbsp; &nbsp; &nbsp; 
<article>
	<hr />
	<h3 id="asoccodepath">ASOC code path
	</h3>
	<p>ref: <a href="https://segmentfault.com/a/1190000041093524">https://segmentfault.com/a/1190000041093524</a>
	</p>
	<ul>
		<li>Platform-specific machine driver - /kernel/msm-5.4/techpack/audio/asoc/sa6155.c&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // for sa6155 chipset
		</li>
		<li>MSM frontend CPU driver − /kernel/msm-5.4/techpack/audio/asoc/msm-dai-fe.c&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  //MSM Frontend DAI driver
		</li>
		<li>Back-end CPU driver − /kernel/msm-5.4/techpack/audio/asoc/msm-dai-q6-v2.c&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //MSM DSP DAI driver（BE DAI）
		</li>
		<li>Stream routing platform driver − /kernel/msm-5.4/techpack/audio/asoc/msm-pcm-routing-v2.c&nbsp; //MSM routing platform driver
		</li>
		<li>Playback and record platform driver − /kernel/msm-5.4/techpack/audio/asoc/msm-pcm-q6-v2.c&nbsp; //PCM module platform driver
		</li>
		<li>Voice platform driver − kernel/msm-5.4/techpack/audio/asoc/msm-pcm-voice-v2.c&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //PCM module platform driver
		</li>
		<li>VoIP platform driver − kernel/msm-5.4/techpack/audio/asoc/msm-pcm-voip-v2.c&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //PCM module platform driver
		</li>
		<li>// ALSA codec drivers − /kernel/sound/soc/codecs/wcdXXXX.c, wcdXXXXtables.c, for example, WCD9330 files are wcd9330.c, wcd9330-tables.c.&nbsp; 
		</li>
		<li>// I2C/SLIMbus drivers − /kernel/drivers/slimbus/slim-msm-ctrl.c, slimbus.c&nbsp; 
		</li>
		<li>ASM driver − kernel/msm-5.4/techpack/audio/dsp/q6asm.c
		</li>
		<li>ADM driver − kernel/msm-5.4/techpack/audio/dsp/q6adm.c 
		</li>
		<li>AFE driver − kernel/msm-5.4/techpack/audio/dsp/q6afe.c&nbsp; 
		</li>
		<li>Voice driver − kernel/msm-5.4/techpack/audio/dsp/q6voice.c 
		</li>
		<li>// Platform-specific machine driver − msmXXXX.c or apqXXXX.c where XXXX is the chipset version; for example, MSM8960 would be msm8960.c.
		</li>
	</ul>
	<hr />
	<h3 id="asocmachinedriver">ASOC Machine driver
	</h3>
	<p>ref: kernel/msm-5.4/techpack/audio/asoc/sa6155.c
	</p>
	<pre>
<code class="hljs rust">module_init(sa6155_init);
    platform_driver_register(&amp;sa6155_asoc_machine_driver);

<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span></span> sa6155_asoc_machine_driver = {
    .driver = {
        .name = DRV_NAME,
        .owner = THIS_MODULE,
        .pm = &amp;snd_soc_pm_ops,
        .of_match_table = sa6155_asoc_machine_of_match,
    },
    .probe = msm_asoc_machine_probe,
    .remove = msm_asoc_machine_remove,
};

<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_ops</span></span> snd_soc_pm_ops = {
    .suspend = snd_soc_suspend,
    .resume = snd_soc_resume,
    .freeze = snd_soc_suspend,
    .thaw = snd_soc_resume,
    .poweroff = snd_soc_poweroff,
    .restore = snd_soc_resume,
};

<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span></span> sa6155_asoc_machine_of_match[]  = {
    { .compatible = <span class="hljs-string">"qcom,sa6155-asoc-snd-adp-star"</span>,
      .data = <span class="hljs-string">"adp_star_codec"</span>},
    { .compatible = <span class="hljs-string">"qcom,sa6155-asoc-snd-custom"</span>,
      .data = <span class="hljs-string">"custom_codec"</span>},
    {},
};


(kernel/msm-<span class="hljs-number">5.4</span>/techpack/audio/asoc/sa6155.c)
msm_asoc_machine_probe
    card = populate_snd_card_dailinks(&amp;pdev-&gt;dev);  <span class="hljs-comment">// dai links信息</span>
    platform_set_drvdata(pdev, card);
    snd_soc_card_set_drvdata(card, pdata);
    ret = snd_soc_of_parse_card_name(card, <span class="hljs-string">"qcom,model"</span>);
    ret = msm_populate_dai_link_component_of_node(card);
    ret = msm_tdm_init(pdev);
    (kernel/msm-<span class="hljs-number">5.4</span>/sound/soc/soc-devres.c)
    ret = devm_snd_soc_register_card(&amp;pdev-&gt;dev, card);
        (kernel/msm-<span class="hljs-number">5.4</span>/sound/soc/soc-core.c)
        ret = snd_soc_register_card(card);
            snd_soc_bind_card(card);
                ret = snd_soc_instantiate_card(card);
                    ret = soc_init_dai_link(card, dai_link);
                    snd_soc_dapm_init(&amp;card-&gt;dapm, card, NULL);
                    ret = soc_bind_dai_link(card, dai_link); <span class="hljs-comment">// 绑定dai link</span>
                        rtd = soc_new_pcm_runtime(card, dai_link);
                        rtd-&gt;cpu_dai = snd_soc_find_dai(dai_link-&gt;cpus); <span class="hljs-comment">//cpus dai匹配</span>
                            snd_soc_is_matching_component(dlc, component) <span class="hljs-comment">// 先匹配of_node,</span>
                            <span class="hljs-comment">// 然后如果dai_name不为空，比较组件驱动名字和dai_link中cpu_dai_name</span>
                            strcmp(dai-&gt;name, dlc-&gt;dai_name)
                        snd_soc_rtdcom_add(rtd, rtd-&gt;cpu_dai-&gt;component);
                        rtd-&gt;codec_dais[i] = snd_soc_find_dai(codec); <span class="hljs-comment">//Find CODEC from registered CODECs</span>
                        snd_soc_rtdcom_add(rtd, rtd-&gt;codec_dais[i]-&gt;component);
                        snd_soc_is_matching_component(platform, component)
                        snd_soc_rtdcom_add(rtd, component);
                        soc_add_pcm_runtime(card, rtd); <span class="hljs-comment">//将rtd-&gt;list加入到card-&gt;rtd_list里</span>
                            list_add_tail(&amp;rtd-&gt;list, &amp;card-&gt;rtd_list);
                            rtd-&gt;num = card-&gt;num_rtd; <span class="hljs-comment">// 设备号，该num即为pcm设备号</span>
                            card-&gt;num_rtd++;  <span class="hljs-comment">// 声卡的运行时例+1</span>
                    ret = soc_bind_aux_dev(card);
                    ret = snd_soc_add_dai_link(card, dai_link);
                    ret = snd_card_new(card-&gt;dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1, card-&gt;owner, <span class="hljs-number">0</span>, &amp;card-&gt;snd_card);
                        err = snd_ctl_create(card);  <span class="hljs-comment">//create control core, called from init.c</span>
                        err = snd_info_card_create(card);  <span class="hljs-comment">//create a card proc file, called from init.c</span>
                    soc_init_card_debugfs(card);
                    soc_resume_init(card);
                    ret = snd_soc_dapm_new_controls(&amp;card-&gt;dapm, card-&gt;dapm_widgets, card-&gt;num_dapm_widgets);
                    ret = snd_soc_dapm_new_controls(&amp;card-&gt;dapm, card-&gt;of_dapm_widgets, card-&gt;num_of_dapm_widgets);
                    ret = card-&gt;probe(card);
                    ret = soc_probe_link_components(card);
                    ret = soc_probe_aux_devices(card);
                    ret = soc_init_dai_link(card, dai_link); <span class="hljs-comment">//Find new DAI links added during probing components and bind them,</span>
                    ret = soc_bind_dai_link(card, dai_link); <span class="hljs-comment">//Components with topology may bring new DAIs and DAI links</span>
                    ret = soc_probe_link_dais(card);  <span class="hljs-comment">//probe all DAI links on this card </span>
                    soc_link_init(card, rtd);
                        ret = soc_rtd_init(rtd, dai_link-&gt;name);
                        soc_dpcm_debugfs_add(rtd);  <span class="hljs-comment">//add DPCM sysfs entries</span>
                        ret = snd_soc_dai_compress_new(cpu_dai, rtd, num); <span class="hljs-comment">//create compress_device if possible</span>
                            dai-&gt;driver-&gt;compress_new(rtd, num);
                        (kernel/msm-<span class="hljs-number">5.4</span>/sound/soc/soc-pcm.c)
                        ret = soc_new_pcm(rtd, num);  <span class="hljs-comment">//create the pcm</span>
                            ret = snd_pcm_new(rtd-&gt;card-&gt;snd_card, new_name, num, playback, capture, &amp;pcm);
                                (kernel/msm-<span class="hljs-number">5.4</span>/sound/core/pcm.c)
                                _snd_pcm_new(card, id, device, playback_count, capture_count, <span class="hljs-literal">false</span>, rpcm); <span class="hljs-comment">//pcm的两个流创建，并将pcm设备加到card-&gt;devices list里</span>
                                    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">snd_device_ops</span></span> ops = {
                                        .dev_free = snd_pcm_dev_free,
                                        .dev_register =    snd_pcm_dev_register,
                                        .dev_disconnect = snd_pcm_dev_disconnect,
                                    };
                                    pcm = kzalloc(sizeof(*pcm), GFP_KERNEL);
                                    err = snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_PLAYBACK, playback_count);
                                    err = snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_CAPTURE, capture_count);
                                        snd_device_initialize(&amp;pstr-&gt;dev, pcm-&gt;card);
                                        dev_set_name(&amp;pstr-&gt;dev, <span class="hljs-string">"pcmC%iD%i%c"</span>, pcm-&gt;card-&gt;number, pcm-&gt;device, stream == SNDRV_PCM_STREAM_PLAYBACK ? <span class="hljs-string">'p'</span> : <span class="hljs-string">'c'</span>);
                                        err = snd_pcm_substream_proc_init(substream);
                                        snd_pcm_group_init(&amp;substream-&gt;self_group);
                                    (kernel/msm-<span class="hljs-number">5.4</span>/sound/core/device.c)
                                    err = snd_device_new(card, SNDRV_DEV_PCM, pcm, internal ? &amp;internal_ops : &amp;ops);
                                        dev = kzalloc(sizeof(*dev), GFP_KERNEL);
                                        list_add(&amp;dev-&gt;list, p);
                            snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &amp;rtd-&gt;ops); <span class="hljs-comment">//注册playback的 substream-&gt;ops</span>
                            snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &amp;rtd-&gt;ops);  <span class="hljs-comment">//注册capture的 substream-&gt;ops</span>
                            ret = snd_soc_pcm_component_new(pcm);
                        ret = soc_link_dai_pcm_new(&amp;cpu_dai, <span class="hljs-number">1</span>, rtd);
                    snd_soc_dapm_link_dai_widgets(card);
                    snd_soc_dapm_connect_dai_link_widgets(card);
                    ret = snd_soc_add_card_controls(card, card-&gt;controls, card-&gt;num_controls);
                    ret = snd_soc_dapm_add_routes(&amp;card-&gt;dapm, card-&gt;dapm_routes, card-&gt;num_dapm_routes);
                    ret = snd_soc_dapm_add_routes(&amp;card-&gt;dapm, card-&gt;of_dapm_routes, card-&gt;num_of_dapm_routes);
                    snd_soc_dapm_new_widgets(card);
                    (kernel/msm-<span class="hljs-number">5.4</span>/sound/core/init.c)
                    ret = snd_card_register(card-&gt;snd_card);
                        err = device_add(&amp;card-&gt;card_dev);
                        (kernel/msm-<span class="hljs-number">5.4</span>/sound/core/device.c)
                        err = snd_device_register_all(card)
                            err = __snd_device_register(dev);
                                int err = dev-&gt;ops-&gt;dev_register(dev);
                                (此函数最终会调用各个devices的snd_device_ops中的dev_register函数注册各个device)
                                (kernel/msm-<span class="hljs-number">5.4</span>/sound/core/pcm.c)
                                snd_pcm_dev_register() <span class="hljs-comment">// for pcm device  pcm.c</span>
                                    err = snd_pcm_add(pcm);
                                    (kernel/msm-<span class="hljs-number">5.4</span>/sound/core/sound.c)
                                    err = snd_register_device(devtype, pcm-&gt;card, pcm-&gt;device, &amp;snd_pcm_f_ops[cidx], pcm, &amp;pcm-&gt;streams[cidx].dev); <span class="hljs-comment">//register pcm</span>
                                snd_ctl_dev_register() <span class="hljs-comment">// for control device  control.c</span>
                                snd_timer_dev_register() <span class="hljs-comment">// for timer device  timer.c</span>
                    dapm_mark_endpoints_dirty(card);
                    snd_soc_dapm_sync(&amp;card-&gt;dapm);    
    ret = msm_get_pinctrl(pdev);
    msm_i2s_auxpcm_init(pdev);
    ret = msm_audio_ssr_register(&amp;pdev-&gt;dev);



（kernel/msm-<span class="hljs-number">5.4</span>/sound/soc/soc-pcm.c）
int soc_new_pcm(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">snd_soc_pcm_runtime</span></span> *rtd, int num)中调用snd_pcm_set_ops函数设置了substream-&gt;ops

    <span class="hljs-comment">/* ASoC PCM operations */</span>
    <span class="hljs-keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic) {
        rtd-&gt;ops.open        = dpcm_fe_dai_open;
        rtd-&gt;ops.hw_params    = dpcm_fe_dai_hw_params;
        rtd-&gt;ops.prepare    = dpcm_fe_dai_prepare;
        rtd-&gt;ops.trigger    = dpcm_fe_dai_trigger;
        rtd-&gt;ops.hw_free    = dpcm_fe_dai_hw_free;
        rtd-&gt;ops.close        = dpcm_fe_dai_close;
        rtd-&gt;ops.pointer    = soc_pcm_pointer;
        rtd-&gt;ops.ioctl        = snd_soc_pcm_component_ioctl;
#ifdef CONFIG_AUDIO_QGKI
        rtd-&gt;ops.compat_ioctl   = soc_pcm_compat_ioctl;
        rtd-&gt;ops.delay_blk    = soc_pcm_delay_blk;
#endif
    } <span class="hljs-keyword">else</span> {
        rtd-&gt;ops.open        = soc_pcm_open;
        rtd-&gt;ops.hw_params    = soc_pcm_hw_params;
        rtd-&gt;ops.prepare    = soc_pcm_prepare;
        rtd-&gt;ops.trigger    = soc_pcm_trigger;
        rtd-&gt;ops.hw_free    = soc_pcm_hw_free;
        rtd-&gt;ops.close        = soc_pcm_close;
        rtd-&gt;ops.pointer    = soc_pcm_pointer;
        rtd-&gt;ops.ioctl        = snd_soc_pcm_component_ioctl;
#ifdef CONFIG_AUDIO_QGKI
        rtd-&gt;ops.compat_ioctl   = soc_pcm_compat_ioctl;
        rtd-&gt;ops.delay_blk    = soc_pcm_delay_blk;
#endif
    }

    <span class="hljs-keyword">if</span> (playback)
        snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &amp;rtd-&gt;ops);

    <span class="hljs-keyword">if</span> (capture)
        snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &amp;rtd-&gt;ops);
</code></pre>
	<hr />
	<h3 id="asocplatformdriver">ASOC Platform driver
	</h3>
	<p>ref: kernel/msm-5.4/sound/soc/soc-core.c<br />platform driver应该只是注册一些结构函数指针，没有匹配设备树调用soc_probe，相应的snd_soc_register_card函数应该是在machine driver匹配时调用的&nbsp; TBD&nbsp; 
	</p>
	<pre>
<code class="hljs cpp">(kernel/msm<span class="hljs-number">-5.4</span>/sound/soc/soc-core.c)
module_init(snd_soc_init);
    snd_soc_init(<span class="hljs-keyword">void</span>)
        snd_soc_debugfs_init();
        snd_soc_util_init();
        platform_driver_register(&amp;soc_driver);

<span class="hljs-comment">/* ASoC platform driver */</span>
<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">soc_driver</span> = {</span>
    .driver        = {
        .name        = <span class="hljs-string">"soc-audio"</span>,
        .pm        = &amp;snd_soc_pm_ops,
    },
    .probe        = soc_probe,
    .remove        = soc_remove,
};

<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_ops</span> <span class="hljs-title">snd_soc_pm_ops</span> = {</span>
    .suspend = snd_soc_suspend,
    .resume = snd_soc_resume,
    .freeze = snd_soc_suspend,
    .thaw = snd_soc_resume,
    .poweroff = snd_soc_poweroff,
    .restore = snd_soc_resume,
};

<span class="hljs-comment">//static int soc_probe(struct platform_device *pdev)</span>
<span class="hljs-comment">//    struct snd_soc_card *card = platform_get_drvdata(pdev);</span>
<span class="hljs-comment">//    snd_soc_register_card(card); //</span>
<span class="hljs-comment">//        snd_soc_bind_card(card);</span>
<span class="hljs-comment">//            ret = snd_soc_instantiate_card(card);</span>
<span class="hljs-comment">//                ...</span>
</code></pre>
	<hr />
	<h3 id="pcmopenwritecallstack">PCM open &amp; write call stack
	</h3>
	<pre>
<code class="hljs rust">声卡
--&gt; 播放流
  --&gt; pcm子流
    --&gt; dpcm前端dai
      --&gt; 后端所有组件打开
        --&gt; 前端所有组件打开 (按照fe dai, codec组件，cpu组件顺序)

<span class="hljs-comment">// 似乎没有用到这里的snd_open</span>
(kernel/msm-<span class="hljs-number">5.4</span>/sound/core/sound.c)
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span></span> snd_fops =
{
    .owner =    THIS_MODULE,
    .open =        snd_open,
    .llseek =    noop_llseek,
};

(kernel/msm-<span class="hljs-number">5.4</span>/sound/core/pcm_native.c)
<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span></span> snd_pcm_f_ops[<span class="hljs-number">2</span>] = {
    {
        .owner =        THIS_MODULE,
        .write =        snd_pcm_write,
        .write_iter =        snd_pcm_writev,
        .open =            snd_pcm_playback_open,
        .release =        snd_pcm_release,
        .llseek =        no_llseek,
        .poll =            snd_pcm_poll,
        .unlocked_ioctl =    snd_pcm_ioctl,
        .compat_ioctl =     snd_pcm_ioctl_compat,
        .mmap =            snd_pcm_mmap,
        .fasync =        snd_pcm_fasync,
        .get_unmapped_area =    snd_pcm_get_unmapped_area,
    },
    {
        .owner =        THIS_MODULE,
        .read =            snd_pcm_read,
        .read_iter =        snd_pcm_readv,
        .open =            snd_pcm_capture_open,
        .release =        snd_pcm_release,
        .llseek =        no_llseek,
        .poll =            snd_pcm_poll,
        .unlocked_ioctl =    snd_pcm_ioctl,
        .compat_ioctl =     snd_pcm_ioctl_compat,
        .mmap =            snd_pcm_mmap,
        .fasync =        snd_pcm_fasync,
        .get_unmapped_area =    snd_pcm_get_unmapped_area,
    }
};

<span class="hljs-comment">// tinyalsa open</span>
<span class="hljs-comment">// PcmTinyAlsaWrapper是我们对tinyalsa的封装</span>
vendor/harman/hardware/audio/audiohal/harman_audio_router/Modules/src/PcmTinyAlsaWrapper.cpp
int PcmTinyAlsaWrapper::openPcmNode()
    external/tinyalsa/pcm.c
    pcm_open(mCardID, mDeviceID, flags, &amp;mConfig);
        pcm-&gt;fd = open(<span class="hljs-function"><span class="hljs-keyword">fn</span>, <span class="hljs-title">O_RDWR</span>|<span class="hljs-title">O_NONBLOCK</span>);  //打开底层设备节点
            <span class="hljs-title">kernel</span>/<span class="hljs-title">msm</span>-5.4/<span class="hljs-title">sound</span>/<span class="hljs-title">core</span>/<span class="hljs-title">pcm_native</span>.<span class="hljs-title">c</span>
            <span class="hljs-title">static</span> <span class="hljs-title">int</span> <span class="hljs-title">snd_pcm_playback_open</span></span>(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span> *inode, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *file)
        ioctl(pcm-&gt;fd, SNDRV_PCM_IOCTL_INFO, &amp;info)) <span class="hljs-comment">//get info</span>
        ioctl(pcm-&gt;fd, SNDRV_PCM_IOCTL_HW_PARAMS, &amp;params) <span class="hljs-comment">//将硬件参数参数写到设备节点中</span>
        pcm-&gt;mmap_buffer = mmap(NULL, pcm_frames_to_bytes(pcm, pcm-&gt;buffer_size), PROT_READ | PROT_WRITE, MAP_FILE | MAP_SHARED, pcm-&gt;fd, <span class="hljs-number">0</span>);  <span class="hljs-comment">//将pcm-&gt;buffer_size映射进内存</span>
        ioctl(pcm-&gt;fd, SNDRV_PCM_IOCTL_SW_PARAMS, &amp;sparams) <span class="hljs-comment">//将软件参数写入到底层设备节点中</span>

<span class="hljs-comment">// tinyalsa open，接snd_pcm_playback_open</span>
kernel/msm-<span class="hljs-number">5.4</span>/sound/core/pcm_native.c
<span class="hljs-keyword">static</span> int snd_pcm_playback_open(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span> *inode, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *file)
    err = snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_PLAYBACK);
        err = snd_card_file_add(pcm-&gt;card, file);
        err = snd_pcm_open_file(file, pcm, stream);
            err = snd_pcm_open_substream(pcm, stream, file, &amp;substream);
                err = snd_pcm_attach_substream(pcm, stream, file, &amp;substream); <span class="hljs-comment">//获取pcm的substream</span>
                err = snd_pcm_hw_constraints_init(substream);  <span class="hljs-comment">//初始化pcm硬件约束</span>
                (kernel/msm-<span class="hljs-number">5.4</span>/sound/soc/soc-pcm.c)
                <span class="hljs-keyword">if</span> ((err = substream-&gt;ops-&gt;open(substream)) &lt; <span class="hljs-number">0</span>)  <span class="hljs-comment">//调用substream的回调函数open,注册声卡时已添加</span>
                (call: <span class="hljs-keyword">static</span> int dpcm_fe_dai_open(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">snd_pcm_substream</span></span> *fe_substream))
                    ret = dpcm_path_get(fe, stream, &amp;list);  <span class="hljs-comment">//找到所有已经激活的链路（widgets）</span>
                    dpcm_process_paths(fe, stream, &amp;list, <span class="hljs-number">1</span>); <span class="hljs-comment">//calculate valid and active FE &lt;-&gt; BE dpcms</span>
                    ret = dpcm_fe_dai_startup(fe_substream);
                        dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);
                        ret = dpcm_be_dai_startup(fe, fe_substream-&gt;stream); <span class="hljs-comment">// BE组件打开</span>
                            soc_pcm_open() <span class="hljs-comment">// 同下fe打开</span>
                        ret = soc_pcm_open(fe_substream);  <span class="hljs-comment">//start the DAI frontend</span>
                            pinctrl_pm_select_default_state(cpu_dai-&gt;dev);
                            pinctrl_pm_select_default_state(codec_dai-&gt;dev);
                            snd_soc_set_runtime_hwparams(substream, &amp;no_host_hardware);
                            ret = snd_soc_dai_startup(cpu_dai, substream);  <span class="hljs-comment">//startup the audio subsystem</span>
                            ret = soc_pcm_components_open(substream, &amp;component); <span class="hljs-comment">//fe dai,codec组件，cpu组件都打开</span>
                                ret = snd_soc_component_module_get_when_open(component);
                                ret = snd_soc_component_open(component, substream);
                                    component-&gt;driver-&gt;ops-&gt;open(substream); <span class="hljs-comment">//调用各个组件的open函数</span>
                                        msm_pcm_open(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">snd_pcm_substream</span></span> *substream)
                                            runtime-&gt;hw = msm_pcm_hardware_playback;  <span class="hljs-comment">// if music, msm-pcm-q6-v2.c</span>
                                            runtime-&gt;hw = msm_pcm_hardware_capture;   <span class="hljs-comment">// if music, msm-pcm-q6-v2.c</span>
                                            runtime-&gt;hw = msm_pcm_hardware;  <span class="hljs-comment">// if voice, msm-pcm-voice-v2.c</span>
                                            snd_soc_set_runtime_hwparams(substream, &amp;dummy_pcm_hardware); <span class="hljs-comment">//msm-pcm-loopback-v2.c</span>
                            ret = snd_soc_dai_startup(codec_dai, substream); <span class="hljs-comment">//codec dai的startup函数</span>
                            ret = rtd-&gt;dai_link-&gt;ops-&gt;startup(substream);
                            snd_soc_runtime_activate(rtd, substream-&gt;stream);
                        dpcm_set_fe_runtime(fe_substream);
                        snd_pcm_limit_hw_rates(runtime);
                        ret = dpcm_apply_symmetry(fe_substream, stream);
                    dpcm_clear_pending_state(fe, stream);
                    dpcm_path_put(&amp;list);
                err = snd_pcm_hw_constraints_complete(substream);  <span class="hljs-comment">//设置pcm硬件约束</span>
            pcm_file-&gt;substream = substream;  <span class="hljs-comment">//将打开的substream保存在pcm_file中</span>
            file-&gt;private_data = pcm_file;   <span class="hljs-comment">//file获得打开的substream</span>



<span class="hljs-comment">// tinyalsa write </span>
<span class="hljs-comment">// PcmTinyAlsaWrapper是我们对tinyalsa的封装</span>
vendor/harman/hardware/audio/audiohal/harman_audio_router/Modules/src/PcmTinyAlsaWrapper.cpp
PcmTinyAlsaWrapper::writeFrame(AudioPort* port, PAF_AudioFrame* data)
    external/tinyalsa/pcm.c
    pcm_mmap_write(mPcmHandle, static_cast&lt;<span class="hljs-keyword">const</span> void*&gt;(pcmData), mAudioParam.convertFramesToBytes(period_size));
    pcm_write(mPcmHandle, static_cast&lt;<span class="hljs-keyword">const</span> void*&gt;(pcmData), mAudioParam.convertFramesToBytes(period_size));
        ioctl(pcm-&gt;fd, SNDRV_PCM_IOCTL_WRITEI_FRAMES, &amp;x)
        kernel/msm-<span class="hljs-number">5.4</span>/sound/core/pcm_native.c
        snd_pcm_ioctl(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *file, unsigned int cmd, unsigned long arg)
            snd_pcm_common_ioctl(file, pcm_file-&gt;substream, cmd, (void __user *)arg);
                snd_pcm_xferi_frames_ioctl(substream, arg);
                    copy_from_user(&amp;xferi, _xferi, sizeof(xferi))
                    snd_pcm_lib_write(substream, xferi.buf, xferi.frames);
                        kernel/msm-<span class="hljs-number">5.4</span>/sound/core/pcm_lib.c
                        __snd_pcm_lib_xfer(substream, (void __force *)buf, <span class="hljs-literal">true</span>, frames, <span class="hljs-literal">false</span>);
                            transfer = substream-&gt;ops-&gt;copy_kernel  <span class="hljs-comment">//拷贝数据,将数据拷贝到dai FIFO？</span>
                            transfer = (pcm_transfer_f)substream-&gt;ops-&gt;copy_user;
                            <span class="hljs-comment">// 这里到底是不是调用了msm_pcm_copy？ msm_pcm_copy中会调用q6asm_write往dsp写数据</span>
                            kernel/msm-<span class="hljs-number">5.4</span>/sound/core/pcm_native.c
                            snd_pcm_start(substream);
                                snd_pcm_action(&amp;snd_pcm_action_start, substream, SNDRV_PCM_STATE_RUNNING);
                                    snd_pcm_action_group(ops, substream, state, <span class="hljs-number">1</span>);
                                    snd_pcm_action_single(ops, substream, state);
                                        res = ops-&gt;pre_action(substream, state);
                                        res = ops-&gt;do_action(substream, state);
                                        snd_pcm_do_start(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">snd_pcm_substream</span></span> *substream, int state)
                                            substream-&gt;ops-&gt;trigger(substream, SNDRV_PCM_TRIGGER_START); <span class="hljs-comment">//触发数据拷贝</span>
                                            <span class="hljs-comment">// 这里到底是不是调用了msm_pcm_trigger？</span>



<span class="hljs-comment">// 不确定substream-&gt;ops-&gt;copy_user调用的是不是如下函数  --TBD</span>
<span class="hljs-comment">// 此函数是应该是发送音频数据</span>
<span class="hljs-keyword">static</span> int msm_pcm_copy(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">snd_pcm_substream</span></span> *substream, int a, unsigned long hwoff, void __user *buf, unsigned long fbytes)
    ret = msm_pcm_capture_copy(substream, a, hwoff, buf, fbytes); <span class="hljs-comment">//substream-&gt;stream == SNDRV_PCM_STREAM_CAPTURE</span>
    ret = msm_pcm_playback_copy(substream, a, hwoff, buf, fbytes); <span class="hljs-comment">//substream-&gt;stream == SNDRV_PCM_STREAM_PLAYBACK</span>
        copy_from_user(bufptr, buf, xfer)  <span class="hljs-comment">//将数据拷贝到内核空间audio_client对应的buffer</span>
        ret = q6asm_write(prtd-&gt;audio_client, xfer, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, NO_TIMESTAMP);
            q6asm_update_token(&amp;write.hdr.token,
                   <span class="hljs-number">0</span>, <span class="hljs-comment">/* Session ID is NA */</span>
                   <span class="hljs-number">0</span>, <span class="hljs-comment">/* Stream ID is NA */</span>
                   port-&gt;dsp_buf,
                   <span class="hljs-number">0</span>, <span class="hljs-comment">/* Direction flag is NA */</span>
                   NO_WAIT_CMD);
            rc = apr_send_pkt(ac-&gt;apr, (uint32_t *) &amp;write);
                rc = apr_tal_write(clnt-&gt;handle, buf, (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">apr_pkt_priv</span></span> *)&amp;svc-&gt;pkt_owner, hdr-&gt;pkt_size); <span class="hljs-comment">//native</span>
                ret = habmm_socket_send(hab_handle_tx, (void *)&amp;apr_tx_buf, apr_send_len, <span class="hljs-number">0</span>);  <span class="hljs-comment">//vm,qnx hypervisor</span>


<span class="hljs-comment">// 不确定substream-&gt;ops-&gt;trigger调用的是不是如下函数  --TBD</span>
<span class="hljs-comment">// 此函数应该是发送操作码命令</span>
kernel/msm-<span class="hljs-number">5.4</span>/techpack/audio/asoc/msm-pcm-q6-v2.c
kernel/msm-<span class="hljs-number">5.4</span>/techpack/audio/asoc/msm-pcm-voice-v2.c
kernel/msm-<span class="hljs-number">5.4</span>/techpack/audio/asoc/msm-pcm-voip-v2.c
kernel/msm-<span class="hljs-number">5.4</span>/techpack/audio/asoc/msm-pcm-loopback-v2.c
kernel/msm-<span class="hljs-number">5.4</span>/techpack/audio/asoc/msm-pcm-q6-noirq.c
<span class="hljs-keyword">static</span> int msm_pcm_trigger(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">snd_pcm_substream</span></span> *substream, int cmd)
    kernel/msm-<span class="hljs-number">5.4</span>/techpack/audio/dsp/q6asm.c    <span class="hljs-comment">//项目用到的目录</span>
    kernel/msm-<span class="hljs-number">5.4</span>/sound/soc/qcom/qdsp6/q6asm.c  <span class="hljs-comment">//这个应该是原始的目录</span>
    ret = q6asm_run_nowait(prtd-&gt;audio_client, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        kernel/msm-<span class="hljs-number">5.4</span>/techpack/audio/dsp/q6asm.c
        __q6asm_cmd_nowait(ac, cmd, ac-&gt;stream_id);
            q6asm_update_token(&amp;hdr.token, ac-&gt;session, stream_id, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, NO_WAIT_CMD);
            kernel/msm-<span class="hljs-number">5.4</span>/techpack/audio/ipc/apr_vm.c
            rc = apr_send_pkt(ac-&gt;apr, (uint32_t *) &amp;hdr);
                rc = apr_tal_write(clnt-&gt;handle, buf, (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">apr_pkt_priv</span></span> *)&amp;svc-&gt;pkt_owner, hdr-&gt;pkt_size); <span class="hljs-comment">//native</span>
                ret = habmm_socket_send(hab_handle_tx, (void *)&amp;apr_tx_buf, apr_send_len, <span class="hljs-number">0</span>);  <span class="hljs-comment">//vm,qnx hypervisor</span>



<span class="hljs-comment">// 不确定substream-&gt;ops-&gt;trigger调用的是不是如下函数  --TBD</span>
substream-&gt;ops-&gt;trigger(substream, SNDRV_PCM_TRIGGER_START);
    dpcm_fe_dai_trigger(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">snd_pcm_substream</span></span> *substream, int cmd)
        dpcm_fe_dai_do_trigger(substream, cmd);
            dpcm_dai_trigger_fe_be(substream, cmd, <span class="hljs-literal">true</span>);
                ret = soc_pcm_trigger(substream, cmd);
                    ret = snd_soc_dai_trigger(codec_dai, substream, cmd);
                    ret = snd_soc_component_trigger(component, substream, cmd);
                    ret = snd_soc_dai_trigger(cpu_dai, substream, cmd);
                ret = dpcm_be_dai_trigger(fe, substream-&gt;stream, cmd);
                                        
                    
</code></pre>
	<p>// need to analyze<br />kernel/msm-5.4/techpack/audio/asoc/msm-pcm-q6-v2.c
	</p>
	<pre>
<code class="hljs arduino"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> struct snd_pcm_ops msm_pcm_ops = {
    .<span class="hljs-built_in">open</span>           = msm_pcm_open,
    .copy_user    = msm_pcm_copy,
    .hw_params    = msm_pcm_hw_params,
    .<span class="hljs-built_in">close</span>          = msm_pcm_close,
    .ioctl          = msm_pcm_ioctl,
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> IS_ENABLED(CONFIG_AUDIO_QGKI)</span>
    .compat_ioctl   = msm_pcm_compat_ioctl,
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* CONFIG_AUDIO_QGKI */</span></span>
    .<span class="hljs-built_in">prepare</span>        = msm_pcm_prepare,
    .trigger        = msm_pcm_trigger,
    .pointer        = msm_pcm_pointer,
    .mmap        = msm_pcm_mmap,
};
</code></pre>
</article>&nbsp; &nbsp; &nbsp; &nbsp;
<footer style="font-size: small; font-style: italic; text-align: right; margin-top: 4em; padding-top: 4px; border-top: 2px solid gray;">
Generated with <a href="http://www.wjjsoft.com/mybase.html?ref=html_export">Mybase Desktop 8.2 Beta-5</a>
</footer>
</body></html>