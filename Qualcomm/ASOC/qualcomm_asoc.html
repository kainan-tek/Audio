<!DOCTYPE html>
<html><head><meta charset="utf-8" /><meta name="Application" content="Mybase Desktop" /><title>qualcomm asoc</title>
<style>
a:hover {
	cursor: pointer;
}

a:hover {
	text-decoration: none;
	background: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCAyMCA0Jz4KPHBhdGggZmlsbD0nbm9uZScgc3Ryb2tlPSdibHVlJyBkPSdNMCAzLjVjNSAwIDUtMyAxMC0zczUgMyAxMCAzIDUtMyAxMC0zIDUgMyAxMCAzJy8+Cjwvc3ZnPgoK") repeat-x 0 100%;
	background-size: 20px auto;
	animation: wave0 1s 10 linear;
}

@keyframes wave0 {
	0% { background-position: 0 100%; }
	100% { background-position: -20px 100%; }
}



pre{
	border: 4px solid #d6d6d6;
	border-radius: 7px;
	padding: 0px;
	margin-right: 0.5em;
}

code{
	font-family: Monaco, Consolas, Monospace, Courier;
	border-radius: 4px;
}

.CLS_InlineCode{
	background-color: DarkCyan;
	color: white;
	padding: 2px 4px;
	margin: 0px 3px;
	font-family: Monaco, Consolas, Monospace, Courier;
}

.CLS_LiteralDollars{
	background-color: default;
	padding: default;
	margin: default;
	border-radius: 0;
}



table{
	border-collapse: collapse;
	border: 1px solid gray;
	border-width: 2px 1px 2px 1px;
	margin-right: 1em;
}

th{
	border: 1px solid gray;
	padding: 4px;
	background-color: #ddd;
}

td{
	border: 1px solid gray;
	padding: 4px;
}

tr{
	background-color: #f0f0f0;
}

tr:nth-child(2n){
	background-color: #f8f8f8;
}



.CLS_THREAD {
	color: blue;
	background-color: #e8e8e8;
	
}

.CLS_THREAD:hover {
	cursor: pointer;
}

.CLS_THREAD:hover {
	text-decoration: none;
	background: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCAyMCA0Jz4KPHBhdGggZmlsbD0nbm9uZScgc3Ryb2tlPSdibHVlJyBkPSdNMCAzLjVjNSAwIDUtMyAxMC0zczUgMyAxMCAzIDUtMyAxMC0zIDUgMyAxMCAzJy8+Cjwvc3ZnPgoK") repeat-x 0 100%;
	background-size: 20px auto;
	animation: wave0 1s infinite linear;
}



#ID_NYF_TOC_PANE {
	margin: 0px;
	padding: 0px;
	border: 1px solid black;
	border-radius: 3px;
	background-color: lightyellow;
	opacity: 0.8;
}

.CLS_NYF_TOC_LISTITEM {
}

.CLS_NYF_TOC_HREF {
	font-size: small;
	text-decoration: underline;
	line-height: 150%;
}



body, table{background-color: rgba(135, 206, 235, 0.313725); font-family: "Microsoft YaHei Mono"; font-size: 12pt}



body,table,code {
    font-family: "Microsoft YaHei Mono", "Consolas", "Courier";
    font-size: 13pt;
}

a {
	color: #0366e6;
	text-decoration: none;
}

a:hover {
	
}

blockquote {
	margin-left: 1em;
	border-left: 6px solid #ddd;
	padding-left: 3px;
	color: #777;
}

hr {
	border: 0;
	border-bottom: 1px solid #ddd;
}

pre {

}

code {

}

p {

}

div {

}

h1 {

}

h2 {

}

h3 {

}

h4 {

}

h5 {

}

h6 {

}

table{

}

th{

}

td{

}

tr{

}

tr:nth-child(2n){

}



.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #abb2bf;
  background: #282c34;
}

.hljs-comment,
.hljs-quote {
  color: #5c6370;
  font-style: italic;
}

.hljs-doctag,
.hljs-keyword,
.hljs-formula {
  color: #c678dd;
}

.hljs-section,
.hljs-name,
.hljs-selector-tag,
.hljs-deletion,
.hljs-subst {
  color: #e06c75;
}

.hljs-literal {
  color: #56b6c2;
}

.hljs-string,
.hljs-regexp,
.hljs-addition,
.hljs-attribute,
.hljs-meta-string {
  color: #98c379;
}

.hljs-built_in,
.hljs-class .hljs-title {
  color: #e6c07b;
}

.hljs-attr,
.hljs-variable,
.hljs-template-variable,
.hljs-type,
.hljs-selector-class,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-number {
  color: #d19a66;
}

.hljs-symbol,
.hljs-bullet,
.hljs-link,
.hljs-meta,
.hljs-selector-id,
.hljs-title {
  color: #61aeee;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}

.hljs-link {
  text-decoration: underline;
}
</style>
</head>&nbsp; &nbsp; &nbsp; &nbsp; <body>&nbsp; &nbsp; &nbsp; &nbsp; 
<article>
	<h2 id="qualcommasoc">Qualcomm ASOC
	</h2>
	<p>ref: <a href="https://segmentfault.com/a/1190000041093524">https://segmentfault.com/a/1190000041093524</a>
	</p>
	<ul>
		<li>Platform-specific machine driver - /kernel/msm-5.4/techpack/audio/asoc/sa6155.c&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // for sa6155 chipset
		</li>
		<li>MSM frontend CPU driver − /kernel/msm-5.4/techpack/audio/asoc/msm-dai-fe.c&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  //MSM Frontend DAI driver
		</li>
		<li>Back-end CPU driver − /kernel/msm-5.4/techpack/audio/asoc/msm-dai-q6-v2.c&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //MSM DSP DAI driver（BE DAI）
		</li>
		<li>Playback and record platform driver − /kernel/msm-5.4/techpack/audio/asoc/msm-pcm-q6-v2.c&nbsp; //PCM module platform driver
		</li>
		<li>Stream routing platform driver − /kernel/msm-5.4/techpack/audio/asoc/msm-pcm-routing-v2.c&nbsp; //MSM routing platform driver
		</li>
		<li>Voice and VoIP platform driver − kernel/msm-5.4/techpack/audio/asoc/msm-pcm-voice-v2.c and msm-pcm-voip-v2.c&nbsp; //PCM module platform driver
		</li>
		<li>// ALSA codec drivers − /kernel/sound/soc/codecs/wcdXXXX.c, wcdXXXXtables.c, for example, WCD9330 files are wcd9330.c, wcd9330-tables.c.&nbsp; 
		</li>
		<li>// I2C/SLIMbus drivers − /kernel/drivers/slimbus/slim-msm-ctrl.c, slimbus.c&nbsp; 
		</li>
		<li>ASM driver − kernel/msm-5.4/techpack/audio/dsp/q6asm.c
		</li>
		<li>ADM driver − kernel/msm-5.4/techpack/audio/dsp/q6adm.c 
		</li>
		<li>AFE driver − kernel/msm-5.4/techpack/audio/dsp/q6afe.c&nbsp; 
		</li>
		<li>Voice driver − kernel/msm-5.4/techpack/audio/dsp/q6voice.c 
		</li>
		<li>// Platform-specific machine driver − msmXXXX.c or apqXXXX.c where XXXX is the chipset version; for example, MSM8960 would be msm8960.c.
		</li>
	</ul>
	<h3 id="asocmachinedriver">ASOC Machine driver
	</h3>
	<p>ref: kernel/msm-5.4/techpack/audio/asoc/sa6155.c
	</p>
	<pre>
<code class="hljs rust">module_init(sa6155_init);
    platform_driver_register(&amp;sa6155_asoc_machine_driver);

<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span></span> sa6155_asoc_machine_driver = {
    .driver = {
        .name = DRV_NAME,
        .owner = THIS_MODULE,
        .pm = &amp;snd_soc_pm_ops,
        .of_match_table = sa6155_asoc_machine_of_match,
    },
    .probe = msm_asoc_machine_probe,
    .remove = msm_asoc_machine_remove,
};

<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_ops</span></span> snd_soc_pm_ops = {
    .suspend = snd_soc_suspend,
    .resume = snd_soc_resume,
    .freeze = snd_soc_suspend,
    .thaw = snd_soc_resume,
    .poweroff = snd_soc_poweroff,
    .restore = snd_soc_resume,
};

<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">of_device_id</span></span> sa6155_asoc_machine_of_match[]  = {
    { .compatible = <span class="hljs-string">"qcom,sa6155-asoc-snd-adp-star"</span>,
      .data = <span class="hljs-string">"adp_star_codec"</span>},
    { .compatible = <span class="hljs-string">"qcom,sa6155-asoc-snd-custom"</span>,
      .data = <span class="hljs-string">"custom_codec"</span>},
    {},
};


(kernel/msm-<span class="hljs-number">5.4</span>/techpack/audio/asoc/sa6155.c)
msm_asoc_machine_probe
    card = populate_snd_card_dailinks(&amp;pdev-&gt;dev);  <span class="hljs-comment">// dai links信息</span>
    platform_set_drvdata(pdev, card);
    snd_soc_card_set_drvdata(card, pdata);
    ret = snd_soc_of_parse_card_name(card, <span class="hljs-string">"qcom,model"</span>);
    ret = msm_populate_dai_link_component_of_node(card);
    ret = msm_tdm_init(pdev);
    (kernel/msm-<span class="hljs-number">5.4</span>/sound/soc/soc-devres.c)
    ret = devm_snd_soc_register_card(&amp;pdev-&gt;dev, card);
        (kernel/msm-<span class="hljs-number">5.4</span>/sound/soc/soc-core.c)
        ret = snd_soc_register_card(card);
            snd_soc_bind_card(card);
                ret = snd_soc_instantiate_card(card);
                    ret = soc_init_dai_link(card, dai_link);
                    snd_soc_dapm_init(&amp;card-&gt;dapm, card, NULL);
                    ret = soc_bind_dai_link(card, dai_link); <span class="hljs-comment">// 绑定dai link</span>
                        rtd = soc_new_pcm_runtime(card, dai_link);
                        rtd-&gt;cpu_dai = snd_soc_find_dai(dai_link-&gt;cpus); <span class="hljs-comment">//cpus dai匹配</span>
                            snd_soc_is_matching_component(dlc, component) <span class="hljs-comment">// 先匹配of_node,</span>
                            <span class="hljs-comment">// 然后如果dai_name不为空，比较组件驱动名字和dai_link中cpu_dai_name</span>
                            strcmp(dai-&gt;name, dlc-&gt;dai_name)
                        snd_soc_rtdcom_add(rtd, rtd-&gt;cpu_dai-&gt;component);
                        rtd-&gt;codec_dais[i] = snd_soc_find_dai(codec); <span class="hljs-comment">//Find CODEC from registered CODECs</span>
                        snd_soc_rtdcom_add(rtd, rtd-&gt;codec_dais[i]-&gt;component);
                        snd_soc_is_matching_component(platform, component)
                        snd_soc_rtdcom_add(rtd, component);
                        soc_add_pcm_runtime(card, rtd); <span class="hljs-comment">//将rtd-&gt;list加入到card-&gt;rtd_list里</span>
                            list_add_tail(&amp;rtd-&gt;list, &amp;card-&gt;rtd_list);
                            rtd-&gt;num = card-&gt;num_rtd; <span class="hljs-comment">// 设备号，该num即为pcm设备号</span>
                            card-&gt;num_rtd++;  <span class="hljs-comment">// 声卡的运行时例+1</span>
                    ret = soc_bind_aux_dev(card);
                    ret = snd_soc_add_dai_link(card, dai_link);
                    ret = snd_card_new(card-&gt;dev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1, card-&gt;owner, <span class="hljs-number">0</span>, &amp;card-&gt;snd_card);
                        err = snd_ctl_create(card);  <span class="hljs-comment">//create control core, called from init.c</span>
                        err = snd_info_card_create(card);  <span class="hljs-comment">//create a card proc file, called from init.c</span>
                    soc_init_card_debugfs(card);
                    soc_resume_init(card);
                    ret = snd_soc_dapm_new_controls(&amp;card-&gt;dapm, card-&gt;dapm_widgets, card-&gt;num_dapm_widgets);
                    ret = snd_soc_dapm_new_controls(&amp;card-&gt;dapm, card-&gt;of_dapm_widgets, card-&gt;num_of_dapm_widgets);
                    ret = card-&gt;probe(card);
                    ret = soc_probe_link_components(card);
                    ret = soc_probe_aux_devices(card);
                    ret = soc_init_dai_link(card, dai_link); <span class="hljs-comment">//Find new DAI links added during probing components and bind them,</span>
                    ret = soc_bind_dai_link(card, dai_link); <span class="hljs-comment">//Components with topology may bring new DAIs and DAI links</span>
                    ret = soc_probe_link_dais(card);  <span class="hljs-comment">//probe all DAI links on this card </span>
                    soc_link_init(card, rtd);
                        ret = soc_rtd_init(rtd, dai_link-&gt;name);
                        soc_dpcm_debugfs_add(rtd);  <span class="hljs-comment">//add DPCM sysfs entries</span>
                        ret = snd_soc_dai_compress_new(cpu_dai, rtd, num); <span class="hljs-comment">//create compress_device if possible</span>
                            dai-&gt;driver-&gt;compress_new(rtd, num);
                        (kernel/msm-<span class="hljs-number">5.4</span>/sound/soc/soc-pcm.c)
                        ret = soc_new_pcm(rtd, num);  <span class="hljs-comment">//create the pcm</span>
                            ret = snd_pcm_new(rtd-&gt;card-&gt;snd_card, new_name, num, playback, capture, &amp;pcm);
                                (kernel/msm-<span class="hljs-number">5.4</span>/sound/core/pcm.c)
                                _snd_pcm_new(card, id, device, playback_count, capture_count, <span class="hljs-literal">false</span>, rpcm); <span class="hljs-comment">//pcm的两个流创建，并将pcm设备加到card-&gt;devices list里</span>
                                    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">snd_device_ops</span></span> ops = {
                                        .dev_free = snd_pcm_dev_free,
                                        .dev_register =    snd_pcm_dev_register,
                                        .dev_disconnect = snd_pcm_dev_disconnect,
                                    };
                                    pcm = kzalloc(sizeof(*pcm), GFP_KERNEL);
                                    err = snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_PLAYBACK, playback_count);
                                    err = snd_pcm_new_stream(pcm, SNDRV_PCM_STREAM_CAPTURE, capture_count);
                                        snd_device_initialize(&amp;pstr-&gt;dev, pcm-&gt;card);
                                        dev_set_name(&amp;pstr-&gt;dev, <span class="hljs-string">"pcmC%iD%i%c"</span>, pcm-&gt;card-&gt;number, pcm-&gt;device, stream == SNDRV_PCM_STREAM_PLAYBACK ? <span class="hljs-string">'p'</span> : <span class="hljs-string">'c'</span>);
                                        err = snd_pcm_substream_proc_init(substream);
                                        snd_pcm_group_init(&amp;substream-&gt;self_group);
                                    (kernel/msm-<span class="hljs-number">5.4</span>/sound/core/device.c)
                                    err = snd_device_new(card, SNDRV_DEV_PCM, pcm, internal ? &amp;internal_ops : &amp;ops);
                                        dev = kzalloc(sizeof(*dev), GFP_KERNEL);
                                        list_add(&amp;dev-&gt;list, p);
                            snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &amp;rtd-&gt;ops); <span class="hljs-comment">//注册playback的 substream-&gt;ops</span>
                            snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &amp;rtd-&gt;ops);  <span class="hljs-comment">//注册capture的 substream-&gt;ops</span>
                            ret = snd_soc_pcm_component_new(pcm);
                        ret = soc_link_dai_pcm_new(&amp;cpu_dai, <span class="hljs-number">1</span>, rtd);
                    snd_soc_dapm_link_dai_widgets(card);
                    snd_soc_dapm_connect_dai_link_widgets(card);
                    ret = snd_soc_add_card_controls(card, card-&gt;controls, card-&gt;num_controls);
                    ret = snd_soc_dapm_add_routes(&amp;card-&gt;dapm, card-&gt;dapm_routes, card-&gt;num_dapm_routes);
                    ret = snd_soc_dapm_add_routes(&amp;card-&gt;dapm, card-&gt;of_dapm_routes, card-&gt;num_of_dapm_routes);
                    snd_soc_dapm_new_widgets(card);
                    (kernel/msm-<span class="hljs-number">5.4</span>/sound/core/init.c)
                    ret = snd_card_register(card-&gt;snd_card);
                        err = device_add(&amp;card-&gt;card_dev);
                        (kernel/msm-<span class="hljs-number">5.4</span>/sound/core/device.c)
                        err = snd_device_register_all(card)
                            err = __snd_device_register(dev);
                                int err = dev-&gt;ops-&gt;dev_register(dev);
                                (此函数最终会调用各个devices的snd_device_ops中的dev_register函数注册各个device)
                                (kernel/msm-<span class="hljs-number">5.4</span>/sound/core/pcm.c)
                                snd_pcm_dev_register() <span class="hljs-comment">// for pcm device  pcm.c</span>
                                    err = snd_pcm_add(pcm);
                                    (kernel/msm-<span class="hljs-number">5.4</span>/sound/core/sound.c)
                                    err = snd_register_device(devtype, pcm-&gt;card, pcm-&gt;device, &amp;snd_pcm_f_ops[cidx], pcm, &amp;pcm-&gt;streams[cidx].dev); <span class="hljs-comment">//register pcm</span>
                                snd_ctl_dev_register() <span class="hljs-comment">// for control device  control.c</span>
                                snd_timer_dev_register() <span class="hljs-comment">// for timer device  timer.c</span>
                    dapm_mark_endpoints_dirty(card);
                    snd_soc_dapm_sync(&amp;card-&gt;dapm);    
    ret = msm_get_pinctrl(pdev);
    msm_i2s_auxpcm_init(pdev);
    ret = msm_audio_ssr_register(&amp;pdev-&gt;dev);



（kernel/msm-<span class="hljs-number">5.4</span>/sound/soc/soc-pcm.c）
int soc_new_pcm(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">snd_soc_pcm_runtime</span></span> *rtd, int num)中调用snd_pcm_set_ops函数设置了substream-&gt;ops

    <span class="hljs-comment">/* ASoC PCM operations */</span>
    <span class="hljs-keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic) {
        rtd-&gt;ops.open        = dpcm_fe_dai_open;
        rtd-&gt;ops.hw_params    = dpcm_fe_dai_hw_params;
        rtd-&gt;ops.prepare    = dpcm_fe_dai_prepare;
        rtd-&gt;ops.trigger    = dpcm_fe_dai_trigger;
        rtd-&gt;ops.hw_free    = dpcm_fe_dai_hw_free;
        rtd-&gt;ops.close        = dpcm_fe_dai_close;
        rtd-&gt;ops.pointer    = soc_pcm_pointer;
        rtd-&gt;ops.ioctl        = snd_soc_pcm_component_ioctl;
#ifdef CONFIG_AUDIO_QGKI
        rtd-&gt;ops.compat_ioctl   = soc_pcm_compat_ioctl;
        rtd-&gt;ops.delay_blk    = soc_pcm_delay_blk;
#endif
    } <span class="hljs-keyword">else</span> {
        rtd-&gt;ops.open        = soc_pcm_open;
        rtd-&gt;ops.hw_params    = soc_pcm_hw_params;
        rtd-&gt;ops.prepare    = soc_pcm_prepare;
        rtd-&gt;ops.trigger    = soc_pcm_trigger;
        rtd-&gt;ops.hw_free    = soc_pcm_hw_free;
        rtd-&gt;ops.close        = soc_pcm_close;
        rtd-&gt;ops.pointer    = soc_pcm_pointer;
        rtd-&gt;ops.ioctl        = snd_soc_pcm_component_ioctl;
#ifdef CONFIG_AUDIO_QGKI
        rtd-&gt;ops.compat_ioctl   = soc_pcm_compat_ioctl;
        rtd-&gt;ops.delay_blk    = soc_pcm_delay_blk;
#endif
    }

    <span class="hljs-keyword">if</span> (playback)
        snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &amp;rtd-&gt;ops);

    <span class="hljs-keyword">if</span> (capture)
        snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &amp;rtd-&gt;ops);
</code></pre>
	<h3 id="asocplatformdriver">ASOC Platform driver
	</h3>
	<p>ref: kernel/msm-5.4/sound/soc/soc-core.c<br />platform driver应该只是注册一些结构函数指针，没有匹配设备树调用soc_probe，相应的snd_soc_register_card函数应该是在machine driver匹配时调用的&nbsp; TBD&nbsp; 
	</p>
	<pre>
<code class="hljs cpp">(kernel/msm<span class="hljs-number">-5.4</span>/sound/soc/soc-core.c)
module_init(snd_soc_init);
    snd_soc_init(<span class="hljs-keyword">void</span>)
        snd_soc_debugfs_init();
        snd_soc_util_init();
        platform_driver_register(&amp;soc_driver);

<span class="hljs-comment">/* ASoC platform driver */</span>
<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">platform_driver</span> <span class="hljs-title">soc_driver</span> = {</span>
    .driver        = {
        .name        = <span class="hljs-string">"soc-audio"</span>,
        .pm        = &amp;snd_soc_pm_ops,
    },
    .probe        = soc_probe,
    .remove        = soc_remove,
};

<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_ops</span> <span class="hljs-title">snd_soc_pm_ops</span> = {</span>
    .suspend = snd_soc_suspend,
    .resume = snd_soc_resume,
    .freeze = snd_soc_suspend,
    .thaw = snd_soc_resume,
    .poweroff = snd_soc_poweroff,
    .restore = snd_soc_resume,
};

<span class="hljs-comment">//static int soc_probe(struct platform_device *pdev)</span>
<span class="hljs-comment">//    struct snd_soc_card *card = platform_get_drvdata(pdev);</span>
<span class="hljs-comment">//    snd_soc_register_card(card); //</span>
<span class="hljs-comment">//        snd_soc_bind_card(card);</span>
<span class="hljs-comment">//            ret = snd_soc_instantiate_card(card);</span>
<span class="hljs-comment">//                ...</span>
</code></pre>
	<h3 id="pcmopencallstack">PCM open call stack
	</h3>
	<pre>
<code class="hljs rust">声卡
--&gt; 播放流
  --&gt; pcm子流
    --&gt; dpcm前端dai
      --&gt; 后端所有组件打开
        --&gt; 前端所有组件打开 (按照fe dai, codec组件，cpu组件顺序)

(kernel/msm-<span class="hljs-number">5.4</span>/sound/core/sound.c)
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span></span> snd_fops =
{
    .owner =    THIS_MODULE,
    .open =        snd_open,
    .llseek =    noop_llseek,
};

(kernel/msm-<span class="hljs-number">5.4</span>/sound/core/pcm_native.c)
<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span></span> snd_pcm_f_ops[<span class="hljs-number">2</span>] = {
    {
        .owner =        THIS_MODULE,
        .write =        snd_pcm_write,
        .write_iter =        snd_pcm_writev,
        .open =            snd_pcm_playback_open,
        .release =        snd_pcm_release,
        .llseek =        no_llseek,
        .poll =            snd_pcm_poll,
        .unlocked_ioctl =    snd_pcm_ioctl,
        .compat_ioctl =     snd_pcm_ioctl_compat,
        .mmap =            snd_pcm_mmap,
        .fasync =        snd_pcm_fasync,
        .get_unmapped_area =    snd_pcm_get_unmapped_area,
    },
    {
        .owner =        THIS_MODULE,
        .read =            snd_pcm_read,
        .read_iter =        snd_pcm_readv,
        .open =            snd_pcm_capture_open,
        .release =        snd_pcm_release,
        .llseek =        no_llseek,
        .poll =            snd_pcm_poll,
        .unlocked_ioctl =    snd_pcm_ioctl,
        .compat_ioctl =     snd_pcm_ioctl_compat,
        .mmap =            snd_pcm_mmap,
        .fasync =        snd_pcm_fasync,
        .get_unmapped_area =    snd_pcm_get_unmapped_area,
    }
};


<span class="hljs-comment">// 上层应用是什么时间以什么api通过调用linux文件操作接口调用到snd_open的？？？  TBD</span>
(kernel/msm-<span class="hljs-number">5.4</span>/sound/core/sound.c)
snd_open
    err = file-&gt;f_op-&gt;open(inode, file);
    (kernel/msm-<span class="hljs-number">5.4</span>/sound/core/pcm_native.c)
    (call: <span class="hljs-keyword">static</span> int snd_pcm_playback_open(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span> *inode, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *file))
            err = snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_PLAYBACK);
                err = snd_card_file_add(pcm-&gt;card, file);
                err = snd_pcm_open_file(file, pcm, stream);
                    err = snd_pcm_open_substream(pcm, stream, file, &amp;substream);
                        err = snd_pcm_attach_substream(pcm, stream, file, &amp;substream); <span class="hljs-comment">//获取pcm的substream</span>
                        err = snd_pcm_hw_constraints_init(substream);  <span class="hljs-comment">//初始化pcm硬件约束</span>
                        (kernel/msm-<span class="hljs-number">5.4</span>/sound/soc/soc-pcm.c)
                        <span class="hljs-keyword">if</span> ((err = substream-&gt;ops-&gt;open(substream)) &lt; <span class="hljs-number">0</span>)  <span class="hljs-comment">//调用substream的回调函数open,注册声卡时已添加</span>
                        (call: <span class="hljs-keyword">static</span> int dpcm_fe_dai_open(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">snd_pcm_substream</span></span> *fe_substream))
                            ret = dpcm_path_get(fe, stream, &amp;list);  <span class="hljs-comment">//找到所有已经激活的链路（widgets）</span>
                            dpcm_process_paths(fe, stream, &amp;list, <span class="hljs-number">1</span>); <span class="hljs-comment">//calculate valid and active FE &lt;-&gt; BE dpcms</span>
                            ret = dpcm_fe_dai_startup(fe_substream);
                                dpcm_set_fe_update_state(fe, stream, SND_SOC_DPCM_UPDATE_FE);
                                ret = dpcm_be_dai_startup(fe, fe_substream-&gt;stream); <span class="hljs-comment">// BE组件打开</span>
                                    soc_pcm_open() <span class="hljs-comment">// 同下fe打开</span>
                                ret = soc_pcm_open(fe_substream);  <span class="hljs-comment">//start the DAI frontend</span>
                                    pinctrl_pm_select_default_state(cpu_dai-&gt;dev);
                                    pinctrl_pm_select_default_state(codec_dai-&gt;dev);
                                    snd_soc_set_runtime_hwparams(substream, &amp;no_host_hardware);
                                    ret = snd_soc_dai_startup(cpu_dai, substream);  <span class="hljs-comment">//startup the audio subsystem</span>
                                    ret = soc_pcm_components_open(substream, &amp;component); <span class="hljs-comment">// fe dai, codec组件，cpu组件都打开</span>
                                        ret = snd_soc_component_module_get_when_open(component);
                                        ret = snd_soc_component_open(component, substream);
                                            component-&gt;driver-&gt;ops-&gt;open(substream); <span class="hljs-comment">//调用各个组件的open函数</span>
                                    ret = snd_soc_dai_startup(codec_dai, substream); <span class="hljs-comment">//codec dai的startup函数</span>
                                    ret = rtd-&gt;dai_link-&gt;ops-&gt;startup(substream);
                                    snd_soc_runtime_activate(rtd, substream-&gt;stream);
                                dpcm_set_fe_runtime(fe_substream);
                                snd_pcm_limit_hw_rates(runtime);
                                ret = dpcm_apply_symmetry(fe_substream, stream);
                            dpcm_clear_pending_state(fe, stream);
                            dpcm_path_put(&amp;list);
                        err = snd_pcm_hw_constraints_complete(substream);  <span class="hljs-comment">//设置pcm硬件约束</span>
                    pcm_file-&gt;substream = substream;  <span class="hljs-comment">//将打开的substream保存在pcm_file中</span>
                    file-&gt;private_data = pcm_file;   <span class="hljs-comment">//file获得打开的substream</span>
</code></pre>
	<p>audiorouter call stack<br />ref: vendor/harman/hardware/audio/audiohal/harman_audio_router/Modules/src/PcmAlsaWrapper.cpp
	</p>
	<pre>
<code class="hljs awk">(vendor<span class="hljs-regexp">/harman/</span>hardware<span class="hljs-regexp">/audio/</span>audiohal<span class="hljs-regexp">/harman_audio_router/</span>Modules<span class="hljs-regexp">/src/</span>PcmAlsaWrapper.cpp)
PcmAlsaWrapper::openPcmNode()
    hwCfgWrapper-&gt;setCmd(HW_CFG_ENABLE, mName,(void *)&amp;mPcmParams);   <span class="hljs-regexp">//</span> 这里是设置adsp的参数

    (vendor<span class="hljs-regexp">/harman/</span>hardware<span class="hljs-regexp">/audio/</span>external<span class="hljs-regexp">/alsa-lib/</span>src<span class="hljs-regexp">/pcm/</span>pcm.c)  <span class="hljs-regexp">//</span> 
    (kernel<span class="hljs-regexp">/msm-5.4/</span>sound<span class="hljs-regexp">/core/</span>pcm_native.c) <span class="hljs-regexp">//</span>
    snd_pcm_open(&amp;mPcmHandle, mName.c_str(), SND_PCM_STREAM_PLAYBACK, <span class="hljs-number">0</span>)  <span class="hljs-regexp">//</span>这里的open好像没有调用到sound.c中的snd_pcm_open，  TBD

    
</code></pre>
	<p>// need to analyze<br />kernel/msm-5.4/techpack/audio/asoc/msm-pcm-q6-v2.c
	</p>
	<pre>
<code class="hljs arduino"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> struct snd_pcm_ops msm_pcm_ops = {
    .<span class="hljs-built_in">open</span>           = msm_pcm_open,
    .copy_user    = msm_pcm_copy,
    .hw_params    = msm_pcm_hw_params,
    .<span class="hljs-built_in">close</span>          = msm_pcm_close,
    .ioctl          = msm_pcm_ioctl,
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> IS_ENABLED(CONFIG_AUDIO_QGKI)</span>
    .compat_ioctl   = msm_pcm_compat_ioctl,
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* CONFIG_AUDIO_QGKI */</span></span>
    .<span class="hljs-built_in">prepare</span>        = msm_pcm_prepare,
    .trigger        = msm_pcm_trigger,
    .pointer        = msm_pcm_pointer,
    .mmap        = msm_pcm_mmap,
};
</code></pre>
</article>&nbsp; &nbsp; &nbsp; &nbsp; </body></html>